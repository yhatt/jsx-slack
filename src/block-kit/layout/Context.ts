import { ContextBlock, ImageElement, MrkdwnElement } from '@slack/types'
import { JSXSlackError } from '../../error'
import { JSXSlack } from '../../jsx'
import { createComponent } from '../../jsx-internals'
import { mrkdwn } from '../composition/Mrkdwn'
import { assignMetaFrom } from '../utils'
import { LayoutBlockProps } from './utils'

interface ContextProps extends LayoutBlockProps {
  children: JSXSlack.ChildElements
}

const endSymbol = Symbol('EndOfContext')

/**
 * [The `context` layout block](https://api.slack.com/reference/messaging/blocks#context)
 * to display the message context with small texts and icon images.
 *
 * `<Context>` allows containing mixed contents consisted of text messages
 * formatted by HTML-like elements and `image` block elements generated by
 * `<Image>` component. Elements for `context` layout block will generate from
 * them cleverly.
 *
 * ```jsx
 * <Blocks>
 *   <Context>
 *     <Image src="https://placekitten.com/100/100" alt="Kitten" />
 *     A kitten and
 *     <Image src="https://placekitten.com/100/100" alt="Kitten" />
 *     more kitten.
 *   </Context>
 * </Blocks>
 * ```
 *
 * And you also can define the text element explicitly through `<span>` tag and
 * `<Mrkdwn>` text composition object.
 *
 * **NOTE**: Slack restricts the number of elements up to 10. jsx-slack throws
 * an error if the number of generated elements was going over the limit.
 *
 * @return The partial JSON for `context` layout block
 * @throws Will throw an error if there are 10 or more generated elements.
 */
export const Context = createComponent<ContextProps, ContextBlock>(
  'Context',
  ({ blockId, children, id, ...rest }) => {
    const elements: (ImageElement | MrkdwnElement)[] = []
    let current: JSXSlack.ChildElement[] = []

    for (const child of [...JSXSlack.Children.toArray(children), endSymbol]) {
      const independentElement: ImageElement | MrkdwnElement | null = (() => {
        if (JSXSlack.isValidElement(child)) {
          // Intrinsic HTML elements
          if (child.$$jsxslack.type === 'span')
            return assignMetaFrom(child, mrkdwn(child))

          if (child.$$jsxslack.type === 'img') {
            const { src, alt } = child.$$jsxslack.props || {}

            return assignMetaFrom(child, {
              type: 'image' as const,
              image_url: src,
              alt_text: alt,
            })
          }

          // Raw objects
          if (typeof child === 'object') {
            const { type, text, image_url, alt_text } = child as any

            if (type === 'mrkdwn' && text) return child as any
            if (type === 'image' && image_url && alt_text)
              return assignMetaFrom(child, {
                type: 'image' as const,
                image_url,
                alt_text,
              })
          }
        }
        return null
      })()

      if (current.length > 0 && (independentElement || child === endSymbol)) {
        const mrkdwnElement = mrkdwn(current)
        if (mrkdwnElement.text) elements.push(mrkdwnElement)

        current = []
      }

      if (independentElement) {
        elements.push(independentElement)
      } else if (child !== endSymbol) {
        current.push(child)
      }
    }

    if (elements.length > 10)
      throw new JSXSlackError(
        `<Context> allows containing up to 10 elements, but the number of generated elements is ${elements.length}.`,
        rest['__source']
      )

    return { type: 'context', block_id: blockId || id, elements }
  }
)
